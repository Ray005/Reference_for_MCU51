C51 COMPILER V9.01   TEMP                                                                  01/14/2021 09:22:52 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE TEMP
OBJECT MODULE PLACED IN temp.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE temp.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\05大实验) DEBUG OBJECTEXTEND P
                    -RINT(.\Listings\temp.lst) TABS(2)

line level    source

   1          #include "temp.h"
   2          //#include "disp.h"
   3          extern unsigned char DisplayData[5];
   4          
   5          unsigned char code smgduan2[17]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,
   6                    0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e};//显示0~F的值
   7          
   8          /*******************************************************************************
   9          * 函 数 名         : Delay1ms
  10          * 函数功能       : 延时函数
  11          * 输    入         : 无
  12          * 输    出         : 无
  13          *******************************************************************************/
  14          
  15          void Delay1ms(uint y)
  16          {
  17   1        uint x;
  18   1        for( ; y>0; y--)
  19   1        {
  20   2          for(x=110; x>0; x--);
  21   2        }
  22   1      }
  23          /*******************************************************************************
  24          * 函 数 名         : Ds18b20Init
  25          * 函数功能       : 初始化
  26          * 输    入         : 无
  27          * 输    出         : 初始化成功返回1，失败返回0
  28          *******************************************************************************/
  29          
  30          uchar Ds18b20Init()
  31          {
  32   1        uchar i;
  33   1        DSPORT = 0;      //将总线拉低480us~960us
  34   1        i = 70; 
  35   1        while(i--);//延时642us
  36   1        DSPORT = 1;     //然后拉高总线，如果DS18B20做出反应会将在15us~60us后总线拉低
  37   1        i = 0;
  38   1        while(DSPORT) //等待DS18B20拉低总线
  39   1        {
  40   2          Delay1ms(1);
  41   2          i++;
  42   2          if(i>5)//等待>5MS
  43   2          {
  44   3            return 0;//初始化失败
  45   3          }
  46   2        
  47   2        }
  48   1        return 1;//初始化成功
  49   1      }
  50          
  51          /*******************************************************************************
  52          * 函 数 名         : Ds18b20WriteByte
  53          * 函数功能       : 向18B20写入一个字节
  54          * 输    入         : 无
C51 COMPILER V9.01   TEMP                                                                  01/14/2021 09:22:52 PAGE 2   

  55          * 输    出         : 无
  56          *******************************************************************************/
  57          
  58          void Ds18b20WriteByte(uchar dat)
  59          {
  60   1        uint i, j;
  61   1      
  62   1        for(j=0; j<8; j++)
  63   1        {
  64   2          DSPORT = 0;         //每写入一位数据之前先把总线拉低1us
  65   2          i++;
  66   2          DSPORT = dat & 0x01;  //然后写入一个数据，从最低位开始
  67   2          i=6;
  68   2          while(i--); //延时68us，持续时间最少60us
  69   2          DSPORT = 1; //然后释放总线，至少1us给总线恢复时间才能接着写入第二个数值
  70   2          dat >>= 1;
  71   2        }
  72   1      }
  73          /*******************************************************************************
  74          * 函 数 名         : Ds18b20ReadByte
  75          * 函数功能       : 读取一个字节
  76          * 输    入         : 无
  77          * 输    出         : 无
  78          *******************************************************************************/
  79          
  80          
  81          uchar Ds18b20ReadByte()
  82          {
  83   1        uchar byte, bi;
  84   1        uint i, j;  
  85   1        for(j=8; j>0; j--)
  86   1        {
  87   2          DSPORT = 0;//先将总线拉低1us
  88   2          i++;
  89   2          DSPORT = 1;//然后释放总线
  90   2          i++;
  91   2          i++;//延时6us等待数据稳定
  92   2          bi = DSPORT;   //读取数据，从最低位开始读取
  93   2          /*将byte左移一位，然后与上右移7位后的bi，注意移动之后移掉那位补0。*/
  94   2          byte = (byte >> 1) | (bi << 7);             
  95   2          i = 4;    //读取完之后等待48us再接着读取下一个数
  96   2          while(i--);
  97   2        }       
  98   1        return byte;
  99   1      }
 100          /*******************************************************************************
 101          * 函 数 名         : Ds18b20ChangTemp
 102          * 函数功能       : 让18b20开始转换温度
 103          * 输    入         : 无
 104          * 输    出         : 无
 105          *******************************************************************************/
 106          
 107          void  Ds18b20ChangTemp()
 108          {
 109   1        Ds18b20Init();
 110   1        Delay1ms(1);
 111   1        Ds18b20WriteByte(0xcc);   //跳过ROM操作命令    
 112   1        Ds18b20WriteByte(0x44);     //温度转换命令
 113   1        //Delay1ms(100);  //等待转换成功，而如果你是一直刷着的话，就不用这个延时了
 114   1         
 115   1      }
 116          /*******************************************************************************
C51 COMPILER V9.01   TEMP                                                                  01/14/2021 09:22:52 PAGE 3   

 117          * 函 数 名         : Ds18b20ReadTempCom
 118          * 函数功能       : 发送读取温度命令
 119          * 输    入         : 无
 120          * 输    出         : 无
 121          *******************************************************************************/
 122          
 123          void  Ds18b20ReadTempCom()
 124          { 
 125   1      
 126   1        Ds18b20Init();
 127   1        Delay1ms(1);
 128   1        Ds18b20WriteByte(0xcc);  //跳过ROM操作命令
 129   1        Ds18b20WriteByte(0xbe);  //发送读取温度命令
 130   1      }
 131          /*******************************************************************************
 132          * 函 数 名         : Ds18b20ReadTemp
 133          * 函数功能       : 读取温度
 134          * 输    入         : 无
 135          * 输    出         : 无
 136          *******************************************************************************/
 137          
 138          int Ds18b20ReadTemp_regular()
 139          {
 140   1        int temp = 0;
 141   1        uchar tmh, tml;
 142   1        //ET0 =0;
 143   1        Ds18b20ChangTemp();       //先写入转换命令
 144   1        Ds18b20ReadTempCom();     //然后等待转换完后发送读取温度命令
 145   1        tml = Ds18b20ReadByte();    //读取温度值共16位，先读低字节
 146   1        tmh = Ds18b20ReadByte();    //再读高字节
 147   1        temp = tmh;
 148   1        temp <<= 8;
 149   1        temp |= tml;
 150   1        //ET0 = 1;
 151   1        return temp;
 152   1        
 153   1      }
 154          
 155          int Ds18b20ReadTemp()
 156          {
 157   1        int temp = 0; 
 158   1        uchar tmh, tml;
 159   1        Ds18b20ChangTemp();       //先写入转换命令
 160   1        Ds18b20ReadTempCom();     //然后等待转换完后发送读取温度命令
 161   1        tml = Ds18b20ReadByte();    //读取温度值共16位，先读低字节
 162   1        tmh = Ds18b20ReadByte();    //再读高字节
 163   1        temp = tmh;
 164   1        temp <<= 8;
 165   1        temp |= tml;
 166   1        return temp;
 167   1        
 168   1      }
 169          
 170          /*******************************************************************************
 171          * 函 数 名         : datapros()
 172          * 函数功能       : 温度读取处理转换函数
 173          * 输    入         : temp
 174          * 输    出         : 无
 175          *******************************************************************************/
 176          
 177          void datapros(int temp)    
 178          {
C51 COMPILER V9.01   TEMP                                                                  01/14/2021 09:22:52 PAGE 4   

 179   1          float tp;  
 180   1        if(temp< 0)       //当温度值为负数
 181   1          {
 182   2          DisplayData[0] = 0x40;    //   -
 183   2          //因为读取的温度是实际温度的补码，所以减1，再取反求出原码
 184   2          temp=temp-1;
 185   2          temp=~temp;
 186   2          tp=temp;
 187   2          temp=tp*0.0625*100+0.5; 
 188   2          //留两个小数点就*100，+0.5是四舍五入，因为C语言浮点数转换为整型的时候把小数点
 189   2          //后面的数自动去掉，不管是否大于0.5，而+0.5之后大于0.5的就是进1了，小于0.5的就
 190   2          //算加上0.5，还是在小数点后面。
 191   2       
 192   2          }
 193   1        else
 194   1          {     
 195   2          DisplayData[0] = 0x00;
 196   2          tp=temp;//因为数据处理有小数点所以将温度赋给一个浮点型变量
 197   2          //如果温度是正的那么，那么正数的原码就是补码它本身
 198   2          temp=tp*0.0625*100+0.5; 
 199   2          //留两个小数点就*100，+0.5是四舍五入，因为C语言浮点数转换为整型的时候把小数点
 200   2          //后面的数自动去掉，不管是否大于0.5，而+0.5之后大于0.5的就是进1了，小于0.5的就
 201   2          //算加上0.5，还是在小数点后面。
 202   2        }
 203   1        DisplayData[1] = ~smgduan2[temp % 10000 / 1000];
 204   1        DisplayData[2] = ~smgduan2[temp % 1000 / 100];
 205   1        DisplayData[3] = ~smgduan2[temp %  100 / 10];
 206   1        DisplayData[4] = ~smgduan2[temp %  10 / 1];
 207   1      
 208   1      }
 209          
 210          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    482    ----
   CONSTANT SIZE    =     17    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
